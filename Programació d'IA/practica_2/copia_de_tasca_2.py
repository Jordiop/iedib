# -*- coding: utf-8 -*-
"""Copia de Tasca 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eLUYQJhfWJykLoaVdP4UCwv8-uOBnlOt

# Programació d'intel·ligència artificial. Tasca del Lliurament 2

Aquest és l'enunciat de la tasca del segon lliurament de Programació d'Intel·ligència Artificial. Es refereix a les tres llibreries que hi hem tractat: **NumPy**, **pandas**, i **matplotlib**. Consta de tres blocs corresponents a cada una de les llibreries. Cada bloc val un terç de la nota de la tasca.

Quan hàgiu acabat de realitzar la tasca, davallau el document .ipynb (menú File, opció Download) i lliurau-lo dins el Moodle de l'aula virtual.

Ànims i endavant!

##Bloc 1: NumPy

Emplena el codi corresponent a cada subapartat, tenint en compte que, quan sigui possible, és millor emprar la programació vectoritzada i les funcions universals de NumPy.

### 1.1. *`ndarrays`* unidimensionals (vectors)

**1.1.1.** Per començar, importa la llibreria numpy amb el seu nom habitual.

Crea un ndarray unidimensional (vector), anomentat a1, de 10 posicions i omple'l amb els 10 primers nombres naturals (de l'1 al 10), però en ordre invers (del 10 a l'1)
"""

import numpy as np

a1 = np.arange(10, 0, -1)
print(a1)

"""**1.1.2.** Crea un altre vector de 10 posicions, a2, i omple'l amb els 10 primers nombres parells."""

a2 = np.arange(2, 21, 2)
print(a2)

"""**1.1.3.** Multiplica per 5 tots els valors del vector a1."""

a1 *= 5
print (a1)

"""**1.1.4.** Obté un nou vector, a3, que sigui la suma d'a1 i a2."""

a3 = a2 + a1
print(a3)

"""**1.1.5.** Obté un nou vector, a4, que sigui la resta d'a1 i a2."""

a4 = a1 - a2
print(a4)

"""**1.1.6.** Canvia de signe tots els valors imparells d'a3 i a4."""

a3[a3 % 2 != 0] *= -1
a4[a4 % 2 != 0] *= -1

print(a3)
print(a4)

"""**1.1.7.** Obté un nou vector, a5, que contengui el mínim de cada posició entre els vectors a3 i a4."""

a5 = np.minimum(a3, a4)
print(a5)

"""**1.1.8.** Fes que tots els valors d'a5 siguin positius."""

a5[a5 < 0] *= -1
print(a5)

"""###1.2. *`ndarrays`* multidimensionals (matrius)

**1.2.1.** Crea un ndarray de 2 dimensions (matriu) de 10 files i 4 columnes, anomenada m1 i omple-a amb nombres aleatoris, seguint una distribució normal estàndard.
"""

m1 = np.random.randn(10,4)
print(m1)

"""**1.2.2.** Obté una nova matriu, m2. Els valors de les 5 primers files seran el doble dels de les 5 primeres files de m1. Els de les 5 darreres files, el triple."""

m2 = np.zeros_like(m1)
m2[:5] = m1[:5] * 2
m2[5:] = m1[5:] * 3

print(m1)
print(m2)

"""**1.2.3.** Obté una nova matriu de booleans, mb, que contingui True si a la posició corresponent de m2 hi ha un valor major que 1 o menor que -1, i False en cas contrari."""

mb = np.zeros_like(m2)
mb = (m2 > 1) | (m2 < -1)
print(mb)

"""**1.2.4.** Multiplica per 100 tots els valors de m2 i arrodoneix a l'enter més proper. Fes també que tots els valors siguin positius."""

m2 = np.abs(np.round(m2 * 100))
print(m2)

"""**1.2.5.** A m2 posa el valor 100 en les posicions tals que tinguem True en mb."""

m2[mb] = 100
print(m2)

"""**1.2.6.** Obté dues noves matrius de 5 files i 2 columnes, m3 i m4. La matriu m3 ha de tenir els valors de les 5 primers files i les 2 primeres columnes de m2. La matriu m4 ha de tenir els valors de les 5 darreres files i les 2 darreres columnes de m2."""

m3 = m2[:5, :2]
m4 = m2[5:, -2:]
print(m3)
print(m4)

"""**1.2.7.** Obté una nova matriu, m5, amb el màxim dels valors de m3 i m4."""

m5 = np.maximum(m3, m4)
print(m5)

"""**1.2.8.** Obté els valors màxims i mínims de la matriu m5."""

max_m5 = m5.max()
min_m5 = m5.min()
print(max_m5)
print(min_m5)

"""##Bloc 2: pandas

Emplena el codi corresponent a cada subapartat, treballant amb la llibreria pandas.

**2.1.** Per començar, importa la llibreria pandas amb el seu nom habitual.

A continuació, carrega en un dataframe el dataset de les pel·lícules i sèries de la plataforma Amazon Prime, publicat a Kaggle per OctopusTeam.  Pots obtenir una còpia en format CSV amb les dades actualitzades fins el 22/10/2024 a https://raw.githubusercontent.com/tnavarrete-iedib/bigdata-24-25/refs/heads/main/prime.csv

Mostra el nombre de sèries i de pel·lícules del dataframe.
"""

import pandas as pd

url = "https://raw.githubusercontent.com/tnavarrete-iedib/bigdata-24-25/refs/heads/main/prime.csv"
df = pd.read_csv(url)

num_series = df[df['type'] == 'TV Show'].shape[0]
num_movies = df[df['type'] == 'Movie'].shape[0]
print("Nombre de sèries:", num_series)
print("Nombre de pel·lícules:", num_movies)

"""**2.2.** Obté la mitjana i la desviació estàndard per a les columnes amb la valoració mitjana en IMDB i el nombre de vots en IMDB."""

imdb_mean = df['imdbAverageRating'].mean()
imdb_std = df['imdbAverageRating'].std()
votes_mean = df['imdbNumVotes'].mean()
votes_std = df['imdbNumVotes'].std()
print("Mitjana valoració IMDB:", imdb_mean)
print("Desviació estàndard valoració IMDB:", imdb_std)
print("Mitjana vots IMDB:", votes_mean)
print("Desviació estàndard vots IMDB:", votes_std)

"""**2.3.** Recupera les 10 sèries llençades el 2024 amb més vots en IMDB, ordenades de més a menys vots."""

top_series_2024 = df[(df['type'] == 'TV Show') & (df['releaseYear'] == 2024)]
top_series_2024 = top_series_2024.nlargest(10, 'imdbNumVotes')
print("Top 10 sèries 2024 per vots:", top_series_2024[['title', 'imdbNumVotes']])

"""**2.4.** Recupera les 10 pel·lícules llençades des de l'any 2000 del gènere ciència ficció (poden haver-hi d'altres gèneres també) amb millor valoració, ordenades de més a menys valoració en IMDB."""

scifi_movies = df[(df['type'] == 'Movie') & (df['releaseYear'] >= 2000) & (df['genres'].str.contains('Science Fiction', na=False)) & (df['genres'].str.contains('Sci-fi', na=False))]
top_scifi_movies = scifi_movies.nlargest(10, 'imdbAverageRating')
print("Top 10 pel·lícules ciència ficció:", top_scifi_movies[['title', 'imdbAverageRating']])

"""**2.5.** Calcula el nombre de pel·lícules que s'han llançat cada any des del 2000."""

movies_per_year = df[(df['type'] == 'Movie') & (df['releaseYear'] >= 2000)].groupby('releaseYear').size()
print("Pel·lícules per any:", movies_per_year)

"""**2.6.** Volem agrupar les pel·lícules per any de llançament, des de l'any 2000. Has d'obtenir dos objectse Series, on en els índexs tendrem l'any i en els valors:
* en un objecte Series, el nombre total de vots en IMDB
* en l'altre objecte Series, la valoració mitjana en IMDB
"""

votes_per_year = df[(df['type'] == 'Movie') & df['releaseYear'] >= 2000].groupby('releaseYear')['imdbNumVotes'].sum()
rating_per_year = df[(df['type'] == 'Movie') & df['releaseYear'] >= 2000].groupby('releaseYear')['imdbAverageRating'].mean()

"""**2.7.** A partir d'aquests dos objectes Series de l'apartat anterior, crea un nou objecte DataFrame amb 3 columnes:
* Any
* Vots en IMDB
* Valoració mitjana en IMDB
"""

df_yearly = pd.DataFrame({
    'Any': votes_per_year.index,
    'Vots en IMDB': votes_per_year.values,
    'Valoració mitjana en IMDB': rating_per_year.values
})
print("DataFrame anual:", df_yearly)

"""**2.8.** Guarda el nou objecte DataFrame en un fitxer CSV al directori 'prime' de la teva unitat de Google Drive.

---


"""

df_yearly.to_csv('/yearly_imdb_data.csv', index=False)

"""##Bloc 3: Matplotlib

A partir del DataFrame de les sèries i pel·lícules d'Amazon Prime del bloc anterior, representa amb Matplotlib una figura amb quatre subplots, organitzats en dues files i dues columnes, d'aquesta manera:
* Superior esquerra: histograma per al nombre de vots en IMDB
* Superior dreta: histograma per a la valoració mitjana en IMDB
* Inferior esquerra: nigul de punts on es relacionen el nombre de vots en IMDB amb la valoració mitjana en IMDB.
* Inferior dreta: diagrama de punts i línies que mostri la variació per anys de la valoració mitjana en IMDB de les pel·lícules llançades des del 2000 (dataframe de l'apartat 2.7).

Cada subplot ha de mostrar el títol corresponent i els eixos han d'incloure marques i una etiqueta descriptiva. A més, el gràfic de cada subplot ha d'utilitzar un color diferent.

Tots els elements han de quedar disposats de manera que es pugui veure tot de manera correcta.

Finalment, fes que es descarregui una imatge de la teva figura.
"""

import matplotlib.pyplot as plt

# 3.1. Figura amb subplots per visualitzar dades
plt.figure(figsize=(10, 8))

# Histograma per al nombre de vots en IMDB
plt.subplot(2, 2, 1)
plt.hist(df['imdbNumVotes'].dropna(), color='skyblue', edgecolor='black')
plt.title('Histograma de vots en IMDB')
plt.xlabel('Nombre de vots')
plt.ylabel('Freqüència')

# Histograma per a la valoració mitjana en IMDB
plt.subplot(2, 2, 2)
plt.hist(df['imdbAverageRating'].dropna(), color='salmon', edgecolor='black')
plt.title('Histograma de valoració mitjana en IMDB')
plt.xlabel('Valoració mitjana')
plt.ylabel('Freqüència')

# Nigul de punts de vots vs valoració mitjana
plt.subplot(2, 2, 3)
plt.scatter(df['imdbNumVotes'], df['imdbAverageRating'], color='purple', alpha=0.5)
plt.title('Nombre de vots vs valoració mitjana')
plt.xlabel('Nombre de vots')
plt.ylabel('Valoració mitjana')

# Diagrama per anys de valoració mitjana en IMDB
plt.subplot(2, 2, 4)
plt.plot(df_yearly['Any'], df_yearly['Valoració mitjana en IMDB'], marker='o', linestyle='-', color='green')
plt.title('Valoració mitjana en IMDB per any')
plt.xlabel('Any')
plt.ylabel('Valoració mitjana')

plt.tight_layout()
plt.savefig('/figura_imdb_data.png')
plt.show()